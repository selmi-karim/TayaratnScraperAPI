{"version":3,"sources":["../src/search.js"],"names":["search","account","breachOptions","Promise","all","test","then","breaches","breachesAndPastes","pastes"],"mappings":";;;;;;AAAA;;;;AACA;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDA,IAAMA,SAAS,SAATA,MAAS,CAACC,OAAD;AAAA,MAAUC,aAAV,uEAA0B,EAA1B;AAAA,SACbC,QAAQC,GAAR,CAAY,CACV,+BAAgBH,OAAhB,EAAyBC,aAAzB,CADU;AAEV;AACA,YAAUG,IAAV,CAAeJ,OAAf,IAA0B,4BAAaA,OAAb,CAA1B,GAAkD,IAHxC,CAAZ,EAIGK,IAJH,CAIQ;AAAA,WAAsB;AAC5BC,gBAAUC,kBAAkB,CAAlB,CADkB;AAE5BC,cAAQD,kBAAkB,CAAlB;AAFoB,KAAtB;AAAA,GAJR,CADa;AAAA,CAAf;;AAUA;;;;;;;;kBAQeR,M","file":"search.js","sourcesContent":["import breachedAccount from './breachedAccount';\nimport pasteAccount from './pasteAccount';\n\n/**\n * Fetches all breaches and all pastes associated with the provided account\n * (email address or username). Note that the remote API does not support\n * querying pastes by username (only email addresses), so in the event the\n * provided account is not a valid email address, only breach data is queried\n * and the \"pastes\" field of the resulting object will always be null. This is\n * exactly how searching via the current web interface behaves, which this\n * convenience method is designed to mimic.\n *\n * @param {string} account an email address or username\n * @param {Object} [breachOptions] a configuration object pertaining to\n * breach queries\n * @param {string} [breachOptions.domain] a domain by which to filter the\n * results (default: all domains)\n * @param {boolean} [breachOptions.truncate] truncate the results to only\n * include the name of each breach (default: false)\n * @returns {Promise} a Promise which resolves to an object containing a\n * \"breaches\" key (which can be null or an array of breach objects) and a\n * \"pastes\" key (which can be null or an array of paste objects), or rejects\n * with an Error\n * @example\n * search('foo')\n *   .then((data) => {\n *     if (data.breaches || data.pastes) {\n *       // ...\n *     } else {\n *       // ...\n *     }\n *   })\n *   .catch((err) => {\n *     // ...\n *   });\n * @example\n * search('nobody@nowhere.com', { truncate: true })\n *   .then((data) => {\n *     if (data.breaches || data.pastes) {\n *       // ...\n *     } else {\n *       // ...\n *     }\n *   })\n *   .catch((err) => {\n *     // ...\n *   });\n *\n * @see https://haveibeenpwned.com/\n * @alias module:search\n */\nconst search = (account, breachOptions = {}) =>\n  Promise.all([\n    breachedAccount(account, breachOptions),\n    // This email regex is garbage but it seems to be what the API uses:\n    /^.+@.+$/.test(account) ? pasteAccount(account) : null,\n  ]).then(breachesAndPastes => ({\n    breaches: breachesAndPastes[0],\n    pastes: breachesAndPastes[1],\n  }));\n\n/**\n * A module for searching all breach and paste data associated with a specific\n * account (email address or username).\n *\n * @module search\n * @example\n * import { search } from 'hibp';\n */\nexport default search;\n"]}